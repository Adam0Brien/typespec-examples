// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { resolvePath, } from "@typespec/compiler";
import { reportDiagnostic, state } from "./lib.js";
import { createProtobufEmitter } from "./transform/index.js";
/**
 * # @typespec/protobuf : Protobuf/gRPC Emitter and Decorators for TypeSpec
 *
 * This module defines an emitter and decorator library for TypeSpec that enables specifying Protobuf services and models.
 */
/**
 * The maximum field index allowed by Protocol Buffers.
 */
const MAX_FIELD_INDEX = 2 ** 29 - 1;
/**
 * The field range between 19000 and 19999 is reserved for Protobuf client implementations.
 */
const IMPLEMENTATION_RESERVED_RANGE = [19000, 19999];
/**
 * Defined in the [ProtoBuf Language Spec](https://developers.google.com/protocol-buffers/docs/reference/proto3-spec#identifiers).
 *
 * ident = letter \{ letter | decimalDigit | "_" \}
 * fullIdent = ident \{ "." ident \}
 */
export const PROTO_FULL_IDENT = /([a-zA-Z][a-zA-Z0-9_]*)+/;
/**
 * Decorate an interface as a service, indicating that it represents a Protobuf `service` declaration.
 *
 * @param ctx - decorator context
 * @param target - the decorated interface
 */
export function $service(ctx, target) {
    ctx.program.stateSet(state.service).add(target);
}
/**
 * Declare a Protobuf package.
 *
 * @param ctx - decorator context
 * @param target - target decorator namespace
 */
export const $package = (ctx, target, details) => {
    ctx.program.stateMap(state.package).set(target, details);
};
/**
 * Determines whether a type represents a Protobuf map.
 *
 * @param program - the program context
 * @param m - the type to test
 * @returns true if the internal representation of a Protobuf map is bound to this type.
 */
export function isMap(program, m) {
    return program.stateSet(state._map).has(m);
}
/**
 * Binds the internal representation of a Protobuf map.
 * @internal
 * @param ctx
 * @param target
 */
export function $_map(ctx, target) {
    ctx.program.stateSet(state._map).add(target);
}
export const $externRef = (ctx, target, path, name) => {
    ctx.program
        .stateMap(state.externRef)
        .set(target, [path.value, name.value]);
};
export const $stream = (ctx, target, mode) => {
    const emitStreamingMode = {
        Duplex: 3 /* StreamingMode.Duplex */,
        In: 2 /* StreamingMode.In */,
        Out: 1 /* StreamingMode.Out */,
        None: 0 /* StreamingMode.None */,
    }[mode.name];
    ctx.program.stateMap(state.stream).set(target, emitStreamingMode);
};
export const $reserve = (ctx, target, ...reservations) => {
    const finalReservations = reservations.filter((v) => v != null);
    ctx.program.stateMap(state.reserve).set(target, finalReservations);
};
export const $message = (ctx, target) => {
    ctx.program.stateSet(state.message).add(target);
};
/**
 * Decorate a model property with a field index. Field indices are required for all fields of emitted messages.
 *
 * @param param0
 * @param target
 * @param fieldIndex
 * @returns
 */
export const $field = (ctx, target, fieldIndex) => {
    if (!Number.isInteger(fieldIndex) || fieldIndex <= 0) {
        reportDiagnostic(ctx.program, {
            code: "field-index",
            messageId: "invalid",
            format: {
                index: String(fieldIndex),
            },
            target,
        });
        return;
    }
    else if (fieldIndex > MAX_FIELD_INDEX) {
        reportDiagnostic(ctx.program, {
            code: "field-index",
            messageId: "out-of-bounds",
            format: {
                index: String(fieldIndex),
                max: String(MAX_FIELD_INDEX + 1),
            },
            target,
        });
        return;
    }
    else if (fieldIndex >= IMPLEMENTATION_RESERVED_RANGE[0] &&
        fieldIndex <= IMPLEMENTATION_RESERVED_RANGE[1]) {
        reportDiagnostic(ctx.program, {
            code: "field-index",
            messageId: "reserved",
            format: {
                index: String(fieldIndex),
            },
            target,
        });
    }
    ctx.program.stateMap(state.fieldIndex).set(target, fieldIndex);
};
/**
 * Emitter main function.
 *
 * @param program - the program to emit
 */
export async function $onEmit(ctx) {
    const emitter = createProtobufEmitter(ctx.program);
    await emitter(resolvePath(ctx.emitterOutputDir), ctx.options);
}
/**
 * Validation function
 */
export async function $onValidate(program) {
    // Is this correct? See https://github.com/microsoft/typespec/issues/1859
    /* c8 ignore next 6 */
    if (program.compilerOptions.noEmit) {
        const options = program.emitters.find((e) => e.emitFunction === $onEmit)
            ?.options;
        const emitter = createProtobufEmitter(program);
        await emitter("", options);
    }
}
export const namespace = "TypeSpec.Protobuf";
//# sourceMappingURL=proto.js.map