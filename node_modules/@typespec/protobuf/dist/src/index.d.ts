export declare const namespace = "TypeSpec.Protobuf";
export * from "./proto.js";
export declare const $lib: import("@typespec/compiler").TypeSpecLibrary<{
    "field-index": {
        readonly missing: import("@typespec/compiler").CallableMessage<["name"]>;
        readonly invalid: import("@typespec/compiler").CallableMessage<["index"]>;
        readonly "out-of-bounds": import("@typespec/compiler").CallableMessage<["index", "max"]>;
        readonly reserved: import("@typespec/compiler").CallableMessage<["index"]>;
        readonly "user-reserved": import("@typespec/compiler").CallableMessage<["index"]>;
        readonly "user-reserved-range": import("@typespec/compiler").CallableMessage<["index"]>;
    };
    "field-name": {
        readonly "user-reserved": import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "root-operation": {
        readonly default: "operations in the root namespace are not supported (no associated Protobuf service)";
    };
    "unsupported-intrinsic": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "unsupported-return-type": {
        readonly default: "Protobuf methods must return a named Model";
    };
    "unsupported-input-type": {
        readonly "wrong-number": "Protobuf methods must accept exactly one Model input (an empty model will do)";
        readonly "wrong-type": "Protobuf methods may only accept a named Model as an input";
        readonly unconvertible: "input parameters cannot be converted to a Protobuf message";
    };
    "unsupported-field-type": {
        readonly unconvertible: import("@typespec/compiler").CallableMessage<["type"]>;
        readonly "unknown-intrinsic": import("@typespec/compiler").CallableMessage<["name"]>;
        readonly "unknown-scalar": import("@typespec/compiler").CallableMessage<["name"]>;
        readonly "recursive-map": "a protobuf map's 'value' type may not refer to another map";
        readonly union: "a message field's type may not be a union";
    };
    "namespace-collision": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "unconvertible-enum": {
        readonly default: "enums must explicitly assign exactly one integer to each member to be used in a Protobuf message";
        readonly "no-zero-first": "the first variant of an enum must be set to zero to be used in a Protobuf message";
    };
    "nested-array": {
        readonly default: "nested arrays are not supported by the Protobuf emitter";
    };
    "invalid-package-name": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "illegal-reservation": {
        readonly default: "reservation value must be a string literal, uint32 literal, or a tuple of two uint32 literals denoting a range";
    };
    "model-not-in-package": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "anonymous-model": {
        readonly default: "anonymous models cannot be used in Protobuf messages";
    };
    "unspeakable-template-argument": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    package: {
        readonly "disallowed-option-type": import("@typespec/compiler").CallableMessage<["name", "type"]>;
    };
}, import("./lib.js").ProtobufEmitterOptions, never>;
//# sourceMappingURL=index.d.ts.map