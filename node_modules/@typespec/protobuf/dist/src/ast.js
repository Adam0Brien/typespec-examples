// Copyright (c) Microsoft Corporation.
// Symbols for type destructuring
const $scalar = Symbol("$scalar");
const $ref = Symbol("$ref");
const $map = Symbol("$map");
/**
 * Create a scalar type by name.
 */
export function scalar(t) {
    return [$scalar, t];
}
/**
 * Create a type reference (symbol) to a named message.
 */
export function ref(t) {
    return [$ref, t];
}
/**
 * Create a map from a key type to a value type.
 */
export function map(k, v) {
    return [$map, k, v];
}
/* c8 ignore start */
// Unreachable, by definition, should not be covered :)
/**
 * Creates a type that will throw an internal error if the system attempts to emit it.
 *
 * @param message - optional message that should be printed
 */
export function unreachable(message = "tried to emit unreachable type") {
    // This little "array-like" object will throw an internal error as soon as the "tag" is inspected.
    return Object.freeze({
        get [0]() {
            throw new Error("Internal Error: " + message);
        },
    });
}
/**
 * A helper function that matches and delegates a Protobuf type to a handler per type.
 *
 * @param type - the Protobuf type to match and delegate
 * @param pattern - the matching pattern of delegates to apply
 * @returns
 */
export function matchType(type, pattern) {
    switch (type[0]) {
        case $ref:
            return pattern.ref(type[1]);
        case $scalar:
            return pattern.scalar(type[1]);
        case $map:
            return pattern.map(type[1], type[2]);
        /* c8 ignore next 5 */
        default:
            const __exhaust = type[0];
            throw new Error(`Internal Error: unreachable matchType variant ${__exhaust}`);
    }
}
//# sourceMappingURL=ast.js.map